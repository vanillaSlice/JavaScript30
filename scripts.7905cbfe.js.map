{"version":3,"sources":["14 - JavaScript References VS Copying/scripts/index.js"],"names":["age","age2","console","log","name","name2","players","team","team2","slice","team3","concat","team4","team5","Array","from","person","captain","number","captain2","Object","assign","number2","mike","social","twitter","instagram","dev","dev2","JSON","parse","stringify"],"mappings":";AAOA,IAAIA,EAAM,IACJC,EAAOD,EACbE,QAAQC,IAAIH,EAAKC,GACjBD,EAAM,IACNE,QAAQC,IAAIH,EAAKC,GAEjB,IAAIG,EAAO,OACLC,EAAQD,EACdF,QAAQC,IAAIC,EAAMC,GAClBD,EAAO,UACPF,QAAQC,IAAIC,EAAMC,GAGlB,IAAMC,EAAU,CAAC,MAAO,QAAS,OAAQ,SAKnCC,EAAOD,EAEbJ,QAAQC,IAAIG,EAASC,GAGrBA,EAAK,GAAK,MAEVL,QAAQC,IAAIG,EAASC,GAYrB,IAAMC,EAAQF,EAAQG,QAEtBD,EAAM,GAAK,OAEXN,QAAQC,IAAIG,EAASE,GAGrB,IAAME,EAAQ,GAAGC,OAAOL,GAGlBM,EAAYN,GAAAA,OAAAA,GAClBM,EAAM,GAAK,OAEXV,QAAQC,IAAIO,EAAOE,GAEnB,IAAMC,EAAQC,MAAMC,KAAKT,GAOnBU,EAAS,CACbZ,KAAM,OACNJ,IAAK,IAIDiB,EAAUD,EAChBC,EAAQC,OAAS,GAEjBhB,QAAQC,IAAIa,EAAQC,GAGpB,IAAME,EAAWC,OAAOC,OAAO,GAAIL,EAAQ,CACzCM,QAAS,MAGXpB,QAAQC,IAAIa,EAAQG,GAOpB,IAAMI,EAAO,CACXnB,KAAM,OACNJ,IAAK,GACLwB,OAAQ,CACNC,QAAS,gBACTC,UAAW,iBAIfxB,QAAQC,IAAIoB,GAEZ,IAAMI,EAAMP,OAAOC,OAAO,GAAIE,GAE9BI,EAAIvB,KAAO,UAEXF,QAAQC,IAAIoB,EAAMI,GAElBA,EAAIH,OAAOC,QAAU,WAErBvB,QAAQC,IAAIoB,EAAMI,GAElB,IAAMC,EAAOC,KAAKC,MAAMD,KAAKE,UAAUJ,IAEvCC,EAAKJ,OAAOC,QAAU,gBAEtBvB,QAAQC,IAAIwB,EAAKC","file":"scripts.7905cbfe.js","sourceRoot":"../src","sourcesContent":["/*\n  eslint-disable\n    no-console,\n    no-unused-vars,\n*/\n\n// start with strings, numbers and booleans\nlet age = 100;\nconst age2 = age;\nconsole.log(age, age2);\nage = 200;\nconsole.log(age, age2);\n\nlet name = 'Mike';\nconst name2 = name;\nconsole.log(name, name2);\nname = 'Michael';\nconsole.log(name, name2);\n\n// Let's say we have an array\nconst players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];\n\n// and we want to make a copy of it.\n\n// You might think we can just do something like this:\nconst team = players;\n\nconsole.log(players, team);\n\n// however what happens when we update that array?\nteam[3] = 'Lux';\n\nconsole.log(players, team);\n\n// now here is the problem!\n\n// oh no - we have edited the original array too!\n\n// Why? It's because that is an array reference, not an array copy.\n// They both point to the same array!\n\n// So, how do we fix this? We take a copy instead!\n\n// one way\nconst team2 = players.slice();\n\nteam2[3] = 'Mike';\n\nconsole.log(players, team2);\n\n// or create a new array and concat the old one in\nconst team3 = [].concat(players);\n\n// or use the new ES6 Spread\nconst team4 = [...players];\nteam4[3] = 'Mike';\n\nconsole.log(team3, team4);\n\nconst team5 = Array.from(players);\n\n// now when we update it, the original one isn't changed\n\n// The same thing goes for objects, let's say we have a person object\n\n// with Objects\nconst person = {\n  name: 'Mike',\n  age: 24,\n};\n\n// and think we make a copy:\nconst captain = person;\ncaptain.number = 99;\n\nconsole.log(person, captain);\n\n// how do we take a copy instead?\nconst captain2 = Object.assign({}, person, {\n  number2: 999,\n});\n\nconsole.log(person, captain2);\n\n// We will hopefully soon see the object ...spread\n// const captain3 = {...person};\n\n// Things to note - this is only 1 level deep - both for Arrays and Objects.\n// lodash has a cloneDeep method, but you should think twice before using it.\nconst mike = {\n  name: 'Mike',\n  age: 24,\n  social: {\n    twitter: '@vanillaSlice',\n    instagram: 'vanillaSlice',\n  },\n};\n\nconsole.log(mike);\n\nconst dev = Object.assign({}, mike);\n\ndev.name = 'Michael';\n\nconsole.log(mike, dev);\n\ndev.social.twitter = '@coolman';\n\nconsole.log(mike, dev);\n\nconst dev2 = JSON.parse(JSON.stringify(dev));\n\ndev2.social.twitter = '@vanillaSlice';\n\nconsole.log(dev, dev2);\n"]}